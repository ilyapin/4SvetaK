# 4SvetaK
Задание
Надо написать на языке С# программу (можно без GUI, обычный консольный ввод через параметры командной строки) реализующую
В многопользовательской игре Agar.io игроки управляют бактериями. У каждой бактерии есть размер - целое положительное число. Если встречаются две бактерии разного размера, то бактерия большего размера поглощает меньшую бактерию. При этом меньшая бактерия исчезает, а размер большей бактерии увеличивается на размер меньшей бактерии. Если встречаются две бактерии равного размера, то ничего не происходит. Побеждает игрок, чья бактерия останется на игровом поле одна.
В игре участвуют n игроков, вам даны размеры их бактерий. Определите, какие из игроков имеют возможность выиграть в этой игре.
Формат входных данных:
Программа получает на вход целое число n, 1 6 n 6 105 - количество игроков.
Следующие n строк содержат по одному числу ai - размеры бактерий, 1 6 ai 6 109. Числа ai заданы в порядке неубывания (отсортированы по возрвстанию).
Формат выходных данных:
Программа должна вывести n чисел равных <0> или <1>, по одному числу в строке. Если i-е число равно 0, то это означает, что i-й игрок (размер бактерии которого первоначально был равен
ai) ни при каких обстоятельствах не может выиграть в этой игре. Если i-е число равно 1, то это означает, что i-й игрок имеет возможность выиграть в этой игре.
Пример
стандартный ввод стандартный вывод
4                      0
1                      0
1                      1
3                      1
4
Замечание
В примере из условия 4 бактерии размерами 1, 1, 3, 4.
Бактерии размером 1 никого не могут съесть, поэтому не могут выиграть.
Бактерия размером 4 может съесть всех.
Бактерия размером 3 может съесть по очереди две бактерии размером 1.
Тогда её размер станет 5, после этого она сможет съесть бактерию размером 4 и выиграть. Ответ: 0,0,1,1

Мой алгоритм
Создается множество (set)  элементов. Значение 0 или 1 для данного элемента из сета присваивается всем равным элементам из исходного ряда. Очевидно, что до какого-то элемента значения будут “0”, а после него будут “1”. Найдём этот “переломный” элемент при помощи бинарного поиска. Сначала возьмём средний элемент сета и проверим, есть ли у него шанс выиграть. Рассмотрим самый благоприятный вариант для выбранного элемента. Перейдем из сета в исходный ряд, выберем в нем впервые встретившийся рассматриваемый элемент (в случае повтора элементов).  
1. Сложим значение  элемента со всеми элементами, которые идут до него (так как он гарантированно их поглощает). С новым значением оставляем элемент на своем месте
2. Проверяем, может ли после этого этот элемент поглотить крайний правый, самый больший элемент.
2.1. Если может, то у элемента в сете статус “1”.
2.2. Если не может, то находим в ряду правее от данного элемента все те элементы, которые он может поглотить (то есть меньшие него). 
2.2.1. Если таких нет, то статус элемента в сете “0”. 
2.2.2 Если такие элементы есть, то складываем рассматриваемый элемент со всеми ними и перемещаем его на место последнего поглощенного элемента. Снова переходим к пункту 2.
3. После определения статуса элемента сужаем диапазон поиска «переломного»  элемента в сете. Если значение элемента “1”, то передвигаем правую границу на данный элемент, если “0”, то левую границу. Выберем средний элемент из нового диапазона и повторим проверку. Когда найдем “переломный” элемент, сможем получить ответ. Все значения до “переломного” элемента - “0”, после - “1”.

